---
layout: single
categories:
 - Unity
---



## Unity Study \#2. Collider와 Rigidbody

#### Collider

Collider 컴포넌트는 물리 충돌 처리를 위한 오브젝트의 형태를 정의합니다.

형태에 따라 BoxCollider, SphereCollider, CapsuleCollider 등이 있으며, 오브젝트의 메시의 형태와는 별개로 다양한 형태로 구성할 수 있습니다. (아래 그림에서 왼쪽부터 Box, Sphere, Capsule)

![Collider](https://user-images.githubusercontent.com/28036481/113551299-5fcf9100-962f-11eb-89d4-f2b085b2b8b1.jpg){:.aligncenter}

1. Static Collider
    바닥이나 벽과 같이 고정된 요소를 만들기 위해 사용되는 콜라이더를 의미합니다. 이처럼 사용할 때에는 Rigidbody 컴포넌트 없이 사용할 수 있습니다. 정적 콜라이더는 프로그램이 돌아가는 동안 위치 변화가 없어야 하고, 만약 위치에 변화가 생기면 물리 엔진 성능에 큰 영향을 미친다고 알려져 있습니다. 물리 엔진은 정적 콜라이더는 절대로 움직이거나 변하지 않는다고 가정하고 최적화를 진행하기 때문입니다. 위치 변화 뿐만 아니라 활성화 / 비활성화, 스케일에 변화 또한 없어야 합니다. 

2. Dynamic Collider

    움직이는 오브젝트의 콜라이더를 동적 콜라이더라고 부르고, 이 때에는 Rigidbody 컴포넌트를 반드시 같이 포함하고 있어야 합니다.



#### Rigidbody

Rigidbody 컴포넌트는 게임 오브젝트의 물리적 동작을 가능하게 해줍니다. 

즉, 어떠한 물체에 물리적인 연산(ex. 공이 중력을 받아 떨어짐, 공이 벽에 부딪혀 튕겨져 나옴)을 하고 싶다면 Rigidbody 컴포넌트를 반드시 추가해주어야 합니다.



#### Collider의 Trigger

콜라이더 컴포넌트를 포함하고 있는 물체는 보통 다른 콜라이더를 통과할 수 없습니다. 그러나 Trigger 프로퍼티를  사용하게 되면, 더 이상 해당 물체는 단단한 물체로서 존재하지 않게 됩니다. 즉, Trigger가 켜져 있다면, 다른 콜라이더 컴포넌트를 통과시킬 수 있는 상태가 된다는 것입니다. 대신 다른 콜라이더와 충돌을 하게 되면 OnTriggerEnter 함수를 호출하여 적절한 액션을 취할 수 있도록 해줍니다(ex. 다른 공간으로 들어가는 순간을 포착). Trigger가 켜져있기 전까지는 충돌 시 OnCollisionEnter 함수가 불리게 됩니다. 

#### Rigidbody의 Kinematic

어떤 경우에는 Rigidbody 컴포넌트가 붙여진 게임 오브젝트라도 물리 엔진에 의해 모션이 제어되는 상황을 원치 않을 수도 있습니다 (ex. 벽을 개발자가 원하는 방향과 모션으로 움직이거나 캐릭터를 스크립트로 제어하되 충돌을 감지하고 싶은 경우). 이런 비 물리적인 모션을 Kinematic 모션이라고 합니다. Rigidbody 컴포넌트의 Kinematic 프로퍼티를 활성화하게 될 경우 더 이상 해당 오브젝트는 물리 연산에 의해 움직이지 않게 됩니다. 주로 정적 콜라이더에 Kinmeatic을 활성화 한 Rigidbody 컴포넌트를 추가해 충돌, 움직임 등은 허용하되 물리 연산을 인가하지 않는 형식으로 많이 사용하게 됩니다 (ex. 움직이는 장애물). 

#### Rigidbody의 휴면 상태

Rigidbody 컴포넌트를 가지고 있는 물체가 정의된 최소 선형 또는 회전 속도보다 느리게 이동하면 물리 엔진에서는 이 오브젝트를 정지했다고 간주합니다. 이 물체가 다시 충돌이나 힘을 받아 깨어나기 전까지는 '휴면' 상태로 이 물체를 분류하고, '휴면' 상태의 오브젝트의 Rigidbody를 대상으로는 상태를 업데이트 하는데 프로세서 시간을 할애하지 않아 효율적으로 자원을 사용합니다.



Collider와 Rigidbody는 위와 같이 밀접한 상관관계를 가지고 있으며, 목적에 맞게 항상 서로를 고려하며 프로그램을 설계 해야 할 것 같습니다.
